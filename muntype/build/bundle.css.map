{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../NewMtype.svelte",
    "../../OldMtype.svelte"
  ],
  "sourcesContent": [
    "\n<style>\n\tmain {\n\t\ttext-align: center;\n\t\tpadding: 1em;\n\t\tmax-width: 240px;\n\t\tmargin: 0 auto;\n\t}\n\n\th1 {\n\t\tcolor: #ff3e00;\n\t\ttext-transform: uppercase;\n\t\tfont-size: 4em;\n\t\tfont-weight: 100;\n\t}\n\n\t@media (min-width: 640px) {\n\t\tmain {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n    .warning {\n        font-size:0.75em;\n        font-weight: 300;\n        margin-top: -1.8em;\n        margin-bottom: 1.8em;\n\n    }\n\n    h3 {\n        margin-top: 4em;\n    }\n    a {\n        text-decoration: underline;\n    }\n    p {\n        max-width: 65ch;\n        margin:auto;\n        text-align: justify;\n    }\n\n</style>\n\n<script>\n    import NewMtype from \"./NewMtype.svelte\"\n    import OldMtype from \"./OldMtype.svelte\"\n\n    import { slide } from 'svelte/transition';\n\timport { quintOut } from 'svelte/easing';\n\n\n    let visible = false;\n</script>\n\n\n<main>\n\t<h1>m(un)type</h1>\n    <div><h2>New Format</h2>\n        <NewMtype/>\n    </div>\n    <div><h2>Old Format</h2>\n        <OldMtype/>\n    </div>\n\n    <h3><button on:click={(e) => {e.preventDefault(); visible = !visible}}>What is this?</button></h3>\n    {#if visible}\n\t<p transition:slide=\"{{delay: 0, duration: 250, easing: quintOut }}\">\n        The scheduling messaging system in the <a\n            href=\"https://github.com/nvi-inc/fs\">VLBI Field System</a> uses a message\n        type \"<code>mtype</code>\" to convert a human readable string into a\n        number. In the current\n        design, a hash function would be inconvenient as there is no easy way\n        to avoid clashes and there are only 28 bits available so using large\n        hash range is not an option. Instead we use an encoding of the strings\n        matched by the regular expression <code>[a-z0-9]*</code>. The old\n        format, pre v9.13, used an encoding which was not completely dense, and\n        to free up a few more bits for flags, the new format was created. This\n        new encoding is a bijection, rather than just an injection as the old type.\n    </p>\n    {/if}\n\n\n</main>\n\n",
    "<script>\n    let name =\"\";\n    let type = \"\"\n\n    const symbols = \"abcdefghijklmnopqrstuvwxyz0123456789\".split('');\n    const base    = symbols.length;\n\n    function mtype(name) {\n        let val    = 0;\n        let offset = 0;\n        let i;\n\n        for (i = 0; i < name.length; i++) {\n            let index = symbols.indexOf(name[i]);\n            if (index < 0)\n                continue;\n\n            val    = base * val + index;\n            offset = base * offset + 1;\n        }\n\n        return (val + offset);\n    }\n\n    function muntype(type) {\n        let offset = 0;\n        let offsetn = base*offset + 1;\n        let len = 0;\n\n        while (offsetn <= type) {\n            len++;\n            offset = offsetn;\n            offsetn = base*offsetn + 1;\n        }\n\n        let name = [];\n\n        type -= offset;\n        while (len >= 0) {\n            len--;\n            name[len] = symbols[type%base];\n            type = Math.floor(type/base); \n        }\n        return name.join(\"\");\n    }\n\n\tfunction setBothFromName(value) {\n        name = value;\n        type = mtype(name);\n\t}\n\n\tfunction setBothFromType(value) {\n        type = +value;\n        name = muntype(type);\n\t}\n\n\n</script>\n\n<input placeholder=\"name\" value={name} on:input=\"{e => setBothFromName(e.target.value)}\" type=string> \n<input placeholder=\"type\" value={type} on:input=\"{e => setBothFromType(e.target.value)}\" type=number>\n\n<style>\n\tinput {\n\t\twidth: 10em;\n\t}\n</style>\n\n",
    "<script>\n    let name =\"\";\n    let type = \"\"\n\n    const symbols = \" abcdefghijklmnopqrstuvwxyz0123456789\".split('');\n\n    function mtype(name) {\n        name = name.toLowerCase();\n        let val = 0;\n        for (let i=0;i<name.length;i++) {\n            let index = symbols.indexOf(name[i]);\n            if(index < 0) {\n                continue;\n            }\n            val += index<<(6*i);\n        }\n        return val;\n    }\n\n    function muntype(type) {\n        let i = 0;\n        let name = [];\n        let base =(1<<6);\n        while (type > 0) {\n            if(type%base >= symbols.length) {\n                console.log('error');\n            } else {\n                name.push(symbols[type%base]);\n            }\n            type = Math.floor(type/base); \n        }\n        return (name.reverse().join(''));\n    }\n\n\tfunction setBothFromName(value) {\n        name = value;\n        type = mtype(name);\n\t}\n\n\tfunction setBothFromType(value) {\n        type = +value;\n        name = muntype(type);\n\t}\n\n\n</script>\n\n<input placeholder=\"name\" value={name} on:input=\"{e => setBothFromName(e.target.value)}\" type=string> \n<input placeholder=\"type\" value={type} on:input=\"{e => setBothFromType(e.target.value)}\" type=number>\n\n<style>\n\tinput {\n\t\twidth: 10em;\n\t}\n</style>\n\n"
  ],
  "names": [],
  "mappings": "AAEC,IAAI,cAAC,CAAC,AACL,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,CAAC,CAAC,IAAI,AACf,CAAC,AAED,EAAE,cAAC,CAAC,AACH,KAAK,CAAE,OAAO,CACd,cAAc,CAAE,SAAS,CACzB,SAAS,CAAE,GAAG,CACd,WAAW,CAAE,GAAG,AACjB,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,IAAI,cAAC,CAAC,AACL,SAAS,CAAE,IAAI,AAChB,CAAC,AACF,CAAC,AASE,EAAE,cAAC,CAAC,AACA,UAAU,CAAE,GAAG,AACnB,CAAC,AACD,CAAC,cAAC,CAAC,AACC,eAAe,CAAE,SAAS,AAC9B,CAAC,AACD,CAAC,cAAC,CAAC,AACC,SAAS,CAAE,IAAI,CACf,OAAO,IAAI,CACX,UAAU,CAAE,OAAO,AACvB,CAAC;ACwBJ,KAAK,cAAC,CAAC,AACN,KAAK,CAAE,IAAI,AACZ,CAAC;ACdD,KAAK,cAAC,CAAC,AACN,KAAK,CAAE,IAAI,AACZ,CAAC"
}